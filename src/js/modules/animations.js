// Animations & Visual Effects Module
// Generated by modularization script to keep advanced animations isolated
import { AdvancedPerformanceMonitor, BrowserCompatibilityDetector } from './utilities.js';

export class AnimationController {
  constructor() {
    this.observerOptions = {
      threshold: 0.1,
      rootMargin: '0px 0px -50px 0px'
    };
    this.init();
  }
  init() {
    if ('IntersectionObserver' in window) {
      this.observer = new IntersectionObserver(
        (entries) => this.handleIntersection(entries),
        this.observerOptions
      );
      // Observe sections for animations
      const sections = document.querySelectorAll('section');
      sections.forEach(section => this.observer.observe(section));
      // Set up staggered project card animations
      this.setupProjectCardAnimations();
    }
  }
  setupProjectCardAnimations() {
    const projectCards = document.querySelectorAll('.project-card');
    const skillCards = document.querySelectorAll('.skill-card');
    // Enhanced project card animations
    projectCards.forEach((card, index) => {
      card.classList.add('fade-in-on-scroll');
      card.style.transitionDelay = `${index * 80}ms`;
      // Observe each card for staggered reveal
      const cardObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            setTimeout(() => {
              entry.target.classList.add('animate');
            }, index * 80);
            cardObserver.unobserve(entry.target);
          }
        });
      }, { threshold: 0.2 });
      cardObserver.observe(card);
    });
    // Enhanced skill card animations
    skillCards.forEach((card, index) => {
      card.classList.add('fade-in-on-scroll');
      card.style.transitionDelay = `${index * 40}ms`;
      const cardObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            setTimeout(() => {
              entry.target.classList.add('animate');
            }, index * 40);
            cardObserver.unobserve(entry.target);
          }
        });
      }, { threshold: 0.1 });
      cardObserver.observe(card);
    });
  }
  handleIntersection(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.style.animation = 'fade-in-up 0.6s ease-out forwards';
        // Track section views for analytics
        if (window.analytics) {
          const sectionId = entry.target.id || 'unknown';
          window.analytics.track('section_view', {
            'event_category': 'engagement',
            'event_label': sectionId
          });
        }
      }
    });
  }
}

export class StarfieldManager {
  constructor() {
    this.icons = [
      '⚛️', '💻', '🐍', '🚀', '☁️', '⚙️', '🔧', '📊', '🗄️', '🔍',
      '⚡', '🔒', '🎯', '📈', '🔬', '🎨', '📱', '💾', '🔗', '📋'
    ];
    this.starfieldContainer = null;
    this.totalIcons = 120; // Reduced from 210 for better performance
    this.isEnabled = !window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    // Advanced animation properties
    this.animationFrame = null;
    this.twinkleInterval = null;
    this.performanceMonitor = new AdvancedPerformanceMonitor();
    this.iconPool = []; // Object pooling for better performance
    this.lastFrameTime = 0;
    this.frameCount = 0;
    this.adaptiveQuality = true;
    if (this.isEnabled) {
      this.init();
    }
  }
  init() {
    this.createStarfield();
    this.generateRandomOpacities();
    this.addTwinklingEffect();
    this.addMouseInteraction();
    this.addScrollBasedAnimation();
    // Add dynamic color transitions for enhanced visual appeal
    // TODO: Temporarily disabled due to cache loading issue
    // this.addDynamicColorTransitions();
  }
  createStarfield() {
    // Create starfield container
    this.starfieldContainer = document.createElement('div');
    this.starfieldContainer.className = 'starfield-background';
    this.starfieldContainer.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: -1;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
      gap: 15px;
      padding: 15px;
      overflow: hidden;
    `;
    // Insert before main content
    const body = document.body;
    const firstChild = body.firstChild;
    body.insertBefore(this.starfieldContainer, firstChild);
    // Generate icons
    for (let i = 0; i < this.totalIcons; i++) {
      this.createStarIcon(i);
    }
  }
  createStarIcon(index) {
    const iconWrapper = document.createElement('div');
    iconWrapper.className = 'starfield-icon-wrapper';
    iconWrapper.style.cssText = `
      display: flex;
      align-items: center;
      justify-content: center;
      transition: var(--transition-base);
      font-size: 24px;
      opacity: ${Math.random() * 0.6 + 0.2};
    `;
    const icon = document.createElement('span');
    const randomIcon = this.icons[Math.floor(Math.random() * this.icons.length)];
    icon.textContent = randomIcon;
    icon.className = 'starfield-icon';
    icon.style.cssText = `
      transition: all 2s cubic-bezier(0.4, 0, 0.2, 1);
      filter: grayscale(70%) brightness(0.8);
    `;
    // Add subtle hover effect
    iconWrapper.addEventListener('mouseenter', () => {
      if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
        icon.style.transform = 'scale(1.1)';
        icon.style.filter = 'grayscale(30%) brightness(1.1)';
      }
    });
    iconWrapper.addEventListener('mouseleave', () => {
      icon.style.transform = 'scale(1)';
      icon.style.filter = 'grayscale(70%) brightness(0.8)';
    });
    iconWrapper.appendChild(icon);
    this.starfieldContainer.appendChild(iconWrapper);
  }
  generateRandomOpacities() {
    // Re-randomize opacities every 30 seconds for subtle variation
    const icons = this.starfieldContainer.querySelectorAll('.starfield-icon');
    const updateOpacities = () => {
      icons.forEach(icon => {
        const newOpacity = Math.random();
        icon.style.opacity = newOpacity;
      });
    };
    // Uncomment below if you want dynamic opacity changes (optional)
    // setInterval(updateOpacities, 30000);
  }
  addTwinklingEffect() {
    const icons = this.starfieldContainer.querySelectorAll('.starfield-icon');
    this.iconPool = Array.from(icons);
    // Simplified twinkling with performance monitoring
    const performanceTwinkle = () => {
      if (!this.isEnabled) return;
      this.performanceMonitor.update();
      // Reduce update frequency based on performance
      const updateInterval = this.performanceMonitor.shouldReduceQuality() ? 5000 : 3000;
      const iconsToUpdate = Math.floor(icons.length * (this.performanceMonitor.shouldReduceQuality() ? 0.02 : 0.05));
      // Simple opacity changes only
      for (let i = 0; i < iconsToUpdate; i++) {
        const randomIcon = this.iconPool[Math.floor(Math.random() * this.iconPool.length)];
        const newOpacity = this.generateSmartOpacity();
        randomIcon.style.opacity = newOpacity;
      }
      this.twinkleInterval = setTimeout(performanceTwinkle, updateInterval);
    };
    // Start the simplified twinkling effect
    performanceTwinkle();
  }
  generateSmartOpacity() {
    // Generate opacity with weighted distribution for more natural effect
    const random = Math.random();
    if (random < 0.1) return 0.1 + Math.random() * 0.2; // 10% very dim
    if (random < 0.3) return 0.8 + Math.random() * 0.2; // 20% very bright
    return 0.3 + Math.random() * 0.5; // 70% medium range
  }
  addMouseInteraction() {
    if (!this.starfieldContainer) return;
    let mouseX = 0;
    let mouseY = 0;
    let lastInteractionTime = 0;
    document.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
      const now = performance.now();
      // Throttle mouse interactions heavily for performance
      if (now - lastInteractionTime < 200) return;
      lastInteractionTime = now;
      // Only update nearby icons (reduced radius)
      const icons = this.starfieldContainer.querySelectorAll('.starfield-icon-wrapper');
      icons.forEach(iconWrapper => {
        const rect = iconWrapper.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const distance = Math.sqrt(Math.pow(mouseX - centerX, 2) + Math.pow(mouseY - centerY, 2));
        if (distance < 100) { // Reduced radius from 150px
          const icon = iconWrapper.querySelector('.starfield-icon');
          const proximityFactor = 1 - (distance / 100);
          const brightness = 0.8 + (proximityFactor * 0.2);
          icon.style.filter = `grayscale(${70 - proximityFactor * 20}%) brightness(${brightness})`;
        }
      });
    });
  }
  addScrollBasedAnimation() {
    // Register scroll handler with the global scroll manager for better performance
    if (window.globalScrollManager) {
      let lastScrollY = window.scrollY;
      const scrollHandler = (scrollY) => {
        if (this.starfieldContainer && Math.abs(scrollY - lastScrollY) > 5) {
          // Simple parallax effect - only at ultimate level
          const animationLevel = document.documentElement.dataset.animationLevel;
          if (animationLevel === 'ultimate') {
            const parallaxOffset = (scrollY - lastScrollY) * 0.05;
            this.starfieldContainer.style.transform = `translateY(${parallaxOffset}px)`;
          }
          lastScrollY = scrollY;
        }
      };
      window.globalScrollManager.addHandler('starfield', scrollHandler);
    }
  }
  addDynamicColorTransitions() {
    // Add subtle color transitions to tech icons for enhanced visual appeal
    if (!this.starfieldContainer) return;
    const icons = this.starfieldContainer.querySelectorAll('.tech-icon');
    icons.forEach(icon => {
      // Add CSS transition for smooth color changes
      icon.style.transition = 'filter 0.3s ease, opacity 0.2s ease';
      // Add hover effect for color enhancement
      icon.addEventListener('mouseenter', () => {
        if (this.performanceMonitor.fps > 30) { // Only on good performance
          icon.style.filter = 'brightness(1.2) saturate(1.1)';
        }
      });
      icon.addEventListener('mouseleave', () => {
        icon.style.filter = '';
      });
    });
  }
  getPerformanceMetrics() {
    return {
      fps: this.performanceMonitor.fps,
      isLowPerformance: this.performanceMonitor.isLowPerformance,
      iconCount: this.totalIcons,
      adaptiveQuality: this.adaptiveQuality
    };
  }
  destroy() {
    // Clean up animations and intervals
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
    }
    if (this.colorAnimationFrame) {
      cancelAnimationFrame(this.colorAnimationFrame);
    }
    if (this.twinkleInterval) {
      clearTimeout(this.twinkleInterval);
    }
    // Remove DOM elements
    if (this.starfieldContainer) {
      this.starfieldContainer.remove();
    }
    // Clean up references
    this.iconPool = [];
    this.performanceMonitor = null;
    this.colorAnimationFrame = null;
  }
}

export class ScrollSaturationController {
  constructor(options = {}) {
    this.root = document.documentElement;
    this.options = {
      maxSaturationDrop: options.maxSaturationDrop ?? 0.25,
      maxOpacityDrop: options.maxOpacityDrop ?? 0.35,
      minSaturation: options.minSaturation ?? 0.6,
      minOpacity: options.minOpacity ?? 0.18
    };
    this.handleScroll = (scrollY) => this.update(scrollY);
    this.handleContrastChange = (event) => this.setEnabled(!event.matches);
    this.handleResize = null;
    this.isInitialized = false;
    this.contrastQuery = window.matchMedia('(prefers-contrast: more)');
    this.enabled = !this.contrastQuery.matches;
    this.observeContrastPreference();
    if (this.enabled) {
      this.initialize();
    }
  }
  observeContrastPreference() {
    if (!this.contrastQuery) return;
    if (typeof this.contrastQuery.addEventListener === 'function') {
      this.contrastQuery.addEventListener('change', this.handleContrastChange);
    } else if (typeof this.contrastQuery.addListener === 'function') {
      this.contrastQuery.addListener(this.handleContrastChange);
    }
  }
  initialize() {
    this.observePresetChanges();
    this.refreshBaseValues();
    this.attachScrollHandler();
    if (!this.handleResize) {
      this.handleResize = () => this.update(window.scrollY);
      window.addEventListener('resize', this.handleResize);
    }
    this.update(window.scrollY);
    this.isInitialized = true;
  }
  setEnabled(enabled) {
    if (this.enabled === enabled) return;
    this.enabled = enabled;
    if (enabled) {
      this.initialize();
    } else {
      this.detachScrollHandler();
      this.resetInlineAdjustments();
      this.isInitialized = false;
    }
  }
  refreshBaseValues() {
    const inlineSaturation = this.root.style.getPropertyValue('--current-saturation');
    const inlineOpacity = this.root.style.getPropertyValue('--current-bg-opacity');
    const previousSaturation = inlineSaturation ? inlineSaturation.trim() : null;
    const previousOpacity = inlineOpacity ? inlineOpacity.trim() : null;
    if (previousSaturation) {
      this.root.style.removeProperty('--current-saturation');
    }
    if (previousOpacity) {
      this.root.style.removeProperty('--current-bg-opacity');
    }
    const computed = getComputedStyle(this.root);
    this.baseSaturation = this.parseVar(computed.getPropertyValue('--current-saturation'), 0.85);
    this.baseOpacity = this.parseVar(computed.getPropertyValue('--current-bg-opacity'), 0.5);
    this.targetSaturation = Math.max(this.options.minSaturation, this.baseSaturation - this.options.maxSaturationDrop);
    this.targetOpacity = Math.max(this.options.minOpacity, this.baseOpacity - this.options.maxOpacityDrop);
    this.lastSaturation = null;
    this.lastOpacity = null;
    if (previousSaturation) {
      this.root.style.setProperty('--current-saturation', previousSaturation);
      this.lastSaturation = this.parseVar(previousSaturation, this.baseSaturation);
    }
    if (previousOpacity) {
      this.root.style.setProperty('--current-bg-opacity', previousOpacity);
      this.lastOpacity = this.parseVar(previousOpacity, this.baseOpacity);
    }
  }
  attachScrollHandler() {
    if (!window.globalScrollManager) return;
    window.globalScrollManager.addHandler('scrollSaturation', this.handleScroll);
  }
  detachScrollHandler() {
    if (window.globalScrollManager) {
      window.globalScrollManager.removeHandler('scrollSaturation');
    }
    if (this.handleResize) {
      window.removeEventListener('resize', this.handleResize);
      this.handleResize = null;
    }
  }
  observePresetChanges() {
    if (this.presetObserver) return;
    this.presetObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'attributes' && mutation.attributeName === 'data-animation-level') {
          this.refreshBaseValues();
          this.update(window.scrollY);
        }
      });
    });
    this.presetObserver.observe(this.root, { attributes: true });
  }
  parseVar(value, fallback) {
    if (typeof value === 'string') {
      const parsed = parseFloat(value.trim());
      if (Number.isFinite(parsed)) {
        return parsed;
      }
    }
    return fallback;
  }
  update(scrollY = window.scrollY) {
    if (!this.enabled) return;
    const progress = this.calculateProgress(scrollY);
    const saturation = this.lerp(this.baseSaturation, this.targetSaturation, progress);
    const opacity = this.lerp(this.baseOpacity, this.targetOpacity, progress);
    if (this.lastSaturation === null || Math.abs(saturation - this.lastSaturation) > 0.005) {
      this.root.style.setProperty('--current-saturation', saturation.toFixed(3));
      this.lastSaturation = saturation;
    }
    if (this.lastOpacity === null || Math.abs(opacity - this.lastOpacity) > 0.005) {
      this.root.style.setProperty('--current-bg-opacity', opacity.toFixed(3));
      this.lastOpacity = opacity;
    }
    this.root.style.setProperty('--scroll-saturation-progress', progress.toFixed(3));
  }
  calculateProgress(scrollY) {
    const maxScroll = Math.max(document.documentElement.scrollHeight - window.innerHeight, 1);
    return Math.min(Math.max(scrollY / maxScroll, 0), 1);
  }
  lerp(start, end, amount) {
    return start + (end - start) * amount;
  }
  resetInlineAdjustments() {
    this.root.style.removeProperty('--current-saturation');
    this.root.style.removeProperty('--current-bg-opacity');
    this.root.style.removeProperty('--scroll-saturation-progress');
    this.lastSaturation = null;
    this.lastOpacity = null;
  }
  getState() {
    return {
      enabled: this.enabled,
      baseSaturation: this.baseSaturation,
      targetSaturation: this.targetSaturation,
      currentSaturation: this.lastSaturation ?? this.baseSaturation,
      baseOpacity: this.baseOpacity,
      targetOpacity: this.targetOpacity,
      currentOpacity: this.lastOpacity ?? this.baseOpacity
    };
  }
}

export class WebGLParticleSystem {
  constructor(canvas) {
    this.canvas = canvas;
    this.compatibilityDetector = new BrowserCompatibilityDetector();
    this.gl = null;
    this.isWebGLSupported = false;
    this.particles = [];
    this.particleCount = 100;
    this.animationId = null;
    this.fallbackMode = false;
    this.initWithFallback();
  }
  initWithFallback() {
    // Try WebGL first
    if (this.compatibilityDetector.features.webgl) {
      try {
        this.gl = this.canvas.getContext('webgl2') || this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl');
        this.isWebGLSupported = !!this.gl;
        if (this.isWebGLSupported) {
          this.init();
          return;
        }
      } catch (e) {
      }
    }
    // Fallback to Canvas 2D
    this.fallbackMode = true;
    this.initCanvasFallback();
  }
  initCanvasFallback() {
    this.ctx = this.canvas.getContext('2d');
    if (!this.ctx) {
      return;
    }
    // Reduce particle count for performance
    this.particleCount = Math.min(50, this.particleCount);
    this.initParticles();
    this.renderCanvasFallback();
  }
  init() {
    if (!this.isWebGLSupported) return;
    try {
      // WebGL setup for high-performance particle rendering
      this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
      this.gl.enable(this.gl.BLEND);
      this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
      // Create particle buffer
      this.initParticles();
      this.createShaders();
      this.render();
    } catch (e) {
      this.fallbackMode = true;
      this.initCanvasFallback();
    }
  }
  renderCanvasFallback() {
    if (!this.ctx) return;
    const animate = () => {
      // Clear canvas
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      // Update and render particles with 2D canvas
      this.particles.forEach(particle => {
        // Update position
        particle.x += particle.vx;
        particle.y += particle.vy;
        // Wrap around screen
        if (particle.x < 0) particle.x = this.canvas.width;
        if (particle.x > this.canvas.width) particle.x = 0;
        if (particle.y < 0) particle.y = this.canvas.height;
        if (particle.y > this.canvas.height) particle.y = 0;
        // Update opacity
        particle.opacity = 0.3 + Math.sin(Date.now() * 0.001 + particle.x * 0.01) * 0.2;
        // Draw particle
        this.ctx.save();
        this.ctx.globalAlpha = particle.opacity;
        this.ctx.fillStyle = `rgb(${Math.floor(particle.color[0] * 255)}, ${Math.floor(particle.color[1] * 255)}, ${Math.floor(particle.color[2] * 255)})`;
        this.ctx.beginPath();
        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.restore();
      });
      this.animationId = requestAnimationFrame(animate);
    };
    animate();
  }
  initParticles() {
    for (let i = 0; i < this.particleCount; i++) {
      this.particles.push({
        x: Math.random() * this.canvas.width,
        y: Math.random() * this.canvas.height,
        vx: (Math.random() - 0.5) * 0.5,
        vy: (Math.random() - 0.5) * 0.5,
        opacity: Math.random() * 0.8 + 0.2,
        size: Math.random() * 3 + 1,
        color: [Math.random(), Math.random(), Math.random()],
        life: 1.0
      });
    }
  }
  createShaders() {
    // Simple vertex shader for particles
    const vertexShaderSource = `
      attribute vec2 position;
      attribute float size;
      attribute float opacity;
      attribute vec3 color;
      varying float vOpacity;
      varying vec3 vColor;
      void main() {
        gl_Position = vec4(position, 0.0, 1.0);
        gl_PointSize = size;
        vOpacity = opacity;
        vColor = color;
      }
    `;
    // Fragment shader for particles
    const fragmentShaderSource = `
      precision mediump float;
      varying float vOpacity;
      varying vec3 vColor;
      void main() {
        float dist = distance(gl_PointCoord, vec2(0.5));
        if (dist > 0.5) discard;
        float alpha = (1.0 - dist * 2.0) * vOpacity;
        gl_FragColor = vec4(vColor, alpha);
      }
    `;
    this.program = this.createProgram(vertexShaderSource, fragmentShaderSource);
  }
  createProgram(vertexSource, fragmentSource) {
    const program = this.gl.createProgram();
    const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource);
    const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource);
    this.gl.attachShader(program, vertexShader);
    this.gl.attachShader(program, fragmentShader);
    this.gl.linkProgram(program);
    return program;
  }
  createShader(type, source) {
    const shader = this.gl.createShader(type);
    this.gl.shaderSource(shader, source);
    this.gl.compileShader(shader);
    return shader;
  }
  render() {
    if (!this.isWebGLSupported) return;
    this.gl.clear(this.gl.COLOR_BUFFER_BIT);
    this.gl.useProgram(this.program);
    // Update and render particles
    this.updateParticles();
    this.renderParticles();
    this.animationId = requestAnimationFrame(() => this.render());
  }
  updateParticles() {
    this.particles.forEach(particle => {
      particle.x += particle.vx;
      particle.y += particle.vy;
      // Wrap around screen
      if (particle.x < 0) particle.x = this.canvas.width;
      if (particle.x > this.canvas.width) particle.x = 0;
      if (particle.y < 0) particle.y = this.canvas.height;
      if (particle.y > this.canvas.height) particle.y = 0;
      // Subtle opacity variation
      particle.opacity = 0.3 + Math.sin(Date.now() * 0.001 + particle.x * 0.01) * 0.2;
    });
  }
  renderParticles() {
    // Convert screen coordinates to WebGL coordinates and render
    const positions = [];
    const sizes = [];
    const opacities = [];
    const colors = [];
    this.particles.forEach(particle => {
      positions.push(
        (particle.x / this.canvas.width) * 2 - 1,
        -((particle.y / this.canvas.height) * 2 - 1)
      );
      sizes.push(particle.size);
      opacities.push(particle.opacity);
      colors.push(...particle.color);
    });
    // Bind and render (simplified for brevity)
    this.gl.drawArrays(this.gl.POINTS, 0, this.particleCount);
  }
  destroy() {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
    }
  }
}

export class AdvancedCursorTrail {
  constructor() {
    this.trail = [];
    this.maxTrailLength = 20;
    this.colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b'];
    this.currentColorIndex = 0;
    this.isActive = true;
    this.init();
  }
  init() {
    document.addEventListener('mousemove', (e) => this.addTrailPoint(e));
    this.animate();
  }
  addTrailPoint(e) {
    if (!this.isActive) return;
    const point = {
      x: e.clientX,
      y: e.clientY,
      timestamp: Date.now(),
      color: this.colors[this.currentColorIndex],
      size: 8
    };
    this.trail.push(point);
    if (this.trail.length > this.maxTrailLength) {
      this.trail.shift();
    }
    // Cycle through colors
    this.currentColorIndex = (this.currentColorIndex + 1) % this.colors.length;
  }
  animate() {
    // Remove old trail points
    const now = Date.now();
    this.trail = this.trail.filter(point => now - point.timestamp < 1000);
    // Update existing trail elements
    this.trail.forEach((point, index) => {
      const age = (now - point.timestamp) / 1000;
      const opacity = Math.max(0, 1 - age);
      const scale = Math.max(0.1, 1 - age * 0.8);
      let element = document.querySelector(`[data-trail-id="${index}"]`);
      if (!element) {
        element = document.createElement('div');
        element.className = 'cursor-trail-point';
        element.setAttribute('data-trail-id', index);
        document.body.appendChild(element);
      }
      element.style.cssText = `
        position: fixed;
        left: ${point.x - point.size/2}px;
        top: ${point.y - point.size/2}px;
        width: ${point.size}px;
        height: ${point.size}px;
        background: ${point.color};
        border-radius: 50%;
        pointer-events: none;
        z-index: 9999;
        opacity: ${opacity};
        transform: scale(${scale});
        transition: all 0.1s ease-out;
        box-shadow: 0 0 10px ${point.color}40;
      `;
    });
    requestAnimationFrame(() => this.animate());
  }
  setActive(active) {
    this.isActive = active;
    if (!active) {
      // Clear trail
      document.querySelectorAll('.cursor-trail-point').forEach(el => el.remove());
      this.trail = [];
    }
  }
}

export class MagneticFieldController {
  constructor() {
    this.magneticElements = [];
    this.strength = 50;
    this.maxDistance = 150;
    this.isActive = true;
    this.init();
  }
  init() {
    // Find elements that should have magnetic effects
    this.magneticElements = Array.from(document.querySelectorAll(
      '.project-card, .skill-card, .social-link, .starfield-icon'
    ));
    document.addEventListener('mousemove', (e) => this.updateMagneticField(e));
  }
  updateMagneticField(e) {
    if (!this.isActive) return;
    this.magneticElements.forEach(element => {
      const rect = element.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      const deltaX = e.clientX - centerX;
      const deltaY = e.clientY - centerY;
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      if (distance < this.maxDistance) {
        const force = (this.maxDistance - distance) / this.maxDistance;
        const moveX = (deltaX / distance) * force * this.strength;
        const moveY = (deltaY / distance) * force * this.strength;
        element.style.transform = `translate(${moveX * 0.3}px, ${moveY * 0.3}px) scale(${1 + force * 0.1})`;
        element.style.transition = 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
        // Add glow effect
        element.style.boxShadow = `0 0 ${20 * force}px rgba(255, 255, 255, ${0.2 * force})`;
      } else {
        element.style.transform = '';
        element.style.boxShadow = '';
      }
    });
  }
  setActive(active) {
    this.isActive = active;
    if (!active) {
      this.magneticElements.forEach(element => {
        element.style.transform = '';
        element.style.boxShadow = '';
      });
    }
  }
}

export class EnhancedScrollAnimations {
  constructor() {
    this.observedElements = new Map();
    this.scrollPosition = 0;
    this.isScrolling = false;
    this.scrollDirection = 'down';
  }
  init() {
    this.setupScrollObserver();
    this.setupSectionAnimations();
    this.setupParallaxElements();
    this.setupScrollIndicator();
  }
  setupScrollObserver() {
    const observerOptions = {
      threshold: [0, 0.1, 0.25, 0.5, 0.75, 1],
      rootMargin: '20px'
    };
    this.observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        const element = entry.target;
        const ratio = entry.intersectionRatio;
        if (ratio > 0.1) {
          this.animateElementIn(element, ratio);
        } else {
          this.animateElementOut(element);
        }
      });
    }, observerOptions);
    // Observe all sections and key elements
    document.querySelectorAll('section, .hero, .skill-card, .project-card').forEach(el => {
      this.observer.observe(el);
    });
  }
  animateElementIn(element, ratio) {
    if (element.classList.contains('hero')) {
      element.style.transform = `translateY(${(1 - ratio) * 30}px)`;
      element.style.opacity = ratio;
    } else if (element.classList.contains('skill-item')) {
      element.style.transform = `translateY(${(1 - ratio) * 20}px) scale(${0.9 + ratio * 0.1})`;
      element.style.opacity = ratio;
    } else if (element.classList.contains('project-card')) {
      element.style.transform = `translateY(${(1 - ratio) * 25}px)`;
      element.style.opacity = ratio;
      element.style.boxShadow = `0 ${ratio * 20}px ${ratio * 40}px rgba(0,0,0,${ratio * 0.1})`;
    } else {
      element.style.transform = `translateY(${(1 - ratio) * 20}px)`;
      element.style.opacity = Math.max(0.3, ratio);
    }
  }
  animateElementOut(element) {
    element.style.transform = '';
    element.style.opacity = '';
    element.style.boxShadow = '';
  }
  setupSectionAnimations() {
    // Register with global scroll manager instead of adding another listener
    if (window.globalScrollManager) {
      let lastScrollY = 0;
      const scrollHandler = (currentScrollY) => {
        this.scrollDirection = currentScrollY > lastScrollY ? 'down' : 'up';
        lastScrollY = currentScrollY;
        this.updateParallaxElements(currentScrollY);
      };
      window.globalScrollManager.addHandler('sectionAnimations', scrollHandler);
    }
  }
  setupParallaxElements() {
    // Add parallax class to background elements
    const hero = document.querySelector('.hero');
    if (hero) {
      hero.classList.add('parallax-element');
      hero.dataset.parallaxSpeed = '0.5';
    }
  }
  updateParallaxElements(scrollY) {
    document.querySelectorAll('.parallax-element').forEach(element => {
      const speed = parseFloat(element.dataset.parallaxSpeed) || 0.5;
      const yPos = -(scrollY * speed);
      element.style.transform = `translateY(${yPos}px)`;
    });
  }
  setupScrollIndicator() {
    const indicator = document.createElement('div');
    indicator.className = 'scroll-progress-indicator';
    indicator.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 0%;
      height: 3px;
      background: linear-gradient(90deg, var(--accent-color), var(--accent-bright));
      z-index: 9999;
      transition: width 0.1s ease;
    `;
    document.body.appendChild(indicator);
    // Register with global scroll manager for better performance
    if (window.globalScrollManager) {
      window.globalScrollManager.addHandler('scrollProgress', (scrollY) => {
        const scrolled = (scrollY / (document.body.scrollHeight - window.innerHeight)) * 100;
        indicator.style.width = scrolled + '%';
      });
    }
  }
}

export class EnhancedHoverEffects {
  constructor() {
    this.activeElements = new Set();
  }
  init() {
    this.setupSkillHovers();
    this.setupProjectHovers();
    this.setupButtonHovers();
    this.setupLinkHovers();
  }
  setupSkillHovers() {
    document.querySelectorAll('.skill-card').forEach(item => {
      item.addEventListener('mouseenter', (e) => {
        e.target.style.transform = 'translateY(-8px) scale(1.05)';
        e.target.style.boxShadow = '0 15px 35px rgba(var(--accent-color), 0.2)';
        e.target.style.zIndex = '10';
        // Add glow effect
        e.target.style.filter = 'brightness(1.1)';
      });
      item.addEventListener('mouseleave', (e) => {
        e.target.style.transform = '';
        e.target.style.boxShadow = '';
        e.target.style.zIndex = '';
        e.target.style.filter = '';
      });
    });
  }
  setupProjectHovers() {
    document.querySelectorAll('.project-card').forEach(card => {
      card.addEventListener('mouseenter', (e) => {
        e.target.style.transform = 'translateY(-12px) rotateX(5deg)';
        e.target.style.boxShadow = '0 25px 50px rgba(0,0,0,0.15)';
        // Animate project metrics
        const metrics = e.target.querySelectorAll('.metric-item');
        metrics.forEach((metric, index) => {
          setTimeout(() => {
            metric.style.transform = 'scale(1.1)';
            metric.style.color = 'var(--accent-bright)';
          }, index * 100);
        });
      });
      card.addEventListener('mouseleave', (e) => {
        e.target.style.transform = '';
        e.target.style.boxShadow = '';
        const metrics = e.target.querySelectorAll('.metric-item');
        metrics.forEach(metric => {
          metric.style.transform = '';
          metric.style.color = '';
        });
      });
    });
  }
  setupButtonHovers() {
    document.querySelectorAll('button, .btn, .hero-cta').forEach(button => {
      button.addEventListener('mouseenter', (e) => {
        e.target.style.transform = 'translateY(-3px) scale(1.02)';
        e.target.style.boxShadow = '0 10px 25px rgba(var(--accent-color), 0.3)';
      });
      button.addEventListener('mouseleave', (e) => {
        e.target.style.transform = '';
        e.target.style.boxShadow = '';
      });
    });
  }
  setupLinkHovers() {
    document.querySelectorAll('a:not(.hero-cta):not(.btn)').forEach(link => {
      link.addEventListener('mouseenter', (e) => {
        e.target.style.textShadow = '0 0 8px var(--accent-color)';
      });
      link.addEventListener('mouseleave', (e) => {
        e.target.style.textShadow = '';
      });
    });
  }
}

export class LoadingAnimations {
  constructor() {
    this.loadedElements = new Set();
  }
  init() {
    this.setupElementStaggering();
    this.setupImageLoadAnimations();
    this.setupFormAnimations();
  }
  setupElementStaggering() {
    // Stagger animations for hero elements
    const heroElements = document.querySelectorAll('.hero-story-intro, .hero-title, .hero-metrics, .hero-description, .hero-actions');
    heroElements.forEach((element, index) => {
      element.style.opacity = '0';
      element.style.transform = 'translateY(30px)';
      setTimeout(() => {
        element.style.transition = 'all 0.8s cubic-bezier(0.22, 1, 0.36, 1)';
        element.style.opacity = '1';
        element.style.transform = 'translateY(0)';
      }, index * 200);
    });
    // Stagger skill items
    const skillItems = document.querySelectorAll('.skill-card');
    skillItems.forEach((item, index) => {
      item.style.opacity = '0';
      item.style.transform = 'translateY(20px) scale(0.9)';
      setTimeout(() => {
        item.style.transition = 'all 0.6s cubic-bezier(0.22, 1, 0.36, 1)';
        item.style.opacity = '1';
        item.style.transform = 'translateY(0) scale(1)';
      }, 500 + (index * 100));
    });
  }
  setupImageLoadAnimations() {
    document.querySelectorAll('img').forEach(img => {
      img.style.opacity = '0';
      img.style.transform = 'scale(0.9)';
      img.addEventListener('load', () => {
        img.style.transition = 'all 0.5s ease';
        img.style.opacity = '1';
        img.style.transform = 'scale(1)';
      });
    });
  }
  setupFormAnimations() {
    const formInputs = document.querySelectorAll('input, textarea');
    formInputs.forEach(input => {
      input.addEventListener('focus', (e) => {
        e.target.style.transform = 'scale(1.02)';
        e.target.style.boxShadow = '0 0 20px rgba(var(--accent-color), 0.2)';
      });
      input.addEventListener('blur', (e) => {
        e.target.style.transform = '';
        e.target.style.boxShadow = '';
      });
    });
  }
}

export class AnimationPresetManager {
  constructor() {
    this.presets = {
      minimal: {
        name: 'Minimal',
        starfieldEnabled: false,
        cursorTrail: false,
        magneticField: false,
        particleSystem: false,
        transitionDuration: '0.2s'
      },
      balanced: {
        name: 'Balanced',
        starfieldEnabled: true,
        cursorTrail: false,
        magneticField: true,
        particleSystem: false,
        transitionDuration: '0.4s'
      },
      enhanced: {
        name: 'Enhanced',
        starfieldEnabled: true,
        cursorTrail: true,
        magneticField: true,
        particleSystem: false,
        transitionDuration: '0.6s'
      },
      ultimate: {
        name: 'Ultimate',
        starfieldEnabled: true,
        cursorTrail: true,
        magneticField: true,
        particleSystem: true,
        transitionDuration: '0.8s'
      }
    };
    this.currentPreset = 'balanced';
    this.controllers = {};
  }
  init(controllers) {
    this.controllers = controllers;
    // Load stored preset or use default
    const storedPreset = this.getStoredPreset();
    this.currentPreset = storedPreset;
    // Apply initial preset and set animation level
    this.applyPreset(this.currentPreset);
    this.createPresetSelector();
  }
  createPresetSelector() {
    const selector = document.createElement('div');
    selector.className = 'animation-preset-selector';
    selector.innerHTML = `
      <div class="preset-selector-wrapper">
        <label for="animation-preset">Animation Level:</label>
        <select id="animation-preset">
          ${Object.keys(this.presets).map(key =>
            `<option value="${key}" ${key === this.currentPreset ? 'selected' : ''}>${this.presets[key].name}</option>`
          ).join('')}
        </select>
      </div>
    `;
    // Add to DOM (preferably in settings area)
    const settingsArea = document.querySelector('.settings') || document.body;
    settingsArea.appendChild(selector);
    selector.querySelector('select').addEventListener('change', (e) => {
      this.setPreset(e.target.value);
    });
  }
  setPreset(presetName) {
    if (!this.presets[presetName]) return;
    this.currentPreset = presetName;
    this.applyPreset(presetName);
    // Store preference
    localStorage.setItem('animationPreset', presetName);
  }
  applyPreset(presetName) {
    const preset = this.presets[presetName];
    // Apply animation level to document element for CSS variable control
    document.documentElement.setAttribute('data-animation-level', presetName);
    // Apply global transition duration
    document.documentElement.style.setProperty('--transition-base', preset.transitionDuration);
    // Toggle systems based on preset
    if (this.controllers.starfield) {
      this.controllers.starfield.isEnabled = preset.starfieldEnabled;
      if (!preset.starfieldEnabled) {
        this.controllers.starfield.destroy();
      }
    }
    if (this.controllers.cursorTrail) {
      this.controllers.cursorTrail.setActive(preset.cursorTrail);
    }
    if (this.controllers.magneticField) {
      this.controllers.magneticField.setActive(preset.magneticField);
    }
    if (this.controllers.particleSystem) {
      preset.particleSystem ?
        this.controllers.particleSystem.init() :
        this.controllers.particleSystem.destroy();
    }
    // Log saturation level change for analytics
    if (window.analyticsTracker) {
      window.analyticsTracker.track('animation_level_changed', {
        level: presetName,
        timestamp: Date.now()
      });
    }
  }
  getStoredPreset() {
    return localStorage.getItem('animationPreset') || 'balanced';
  }
}

export class AdvancedAnimationController {
  constructor() {
    this.animations = new Map();
    this.observers = new Map();
    this.isVisible = true;
    this.performanceMode = 'auto'; // 'auto', 'high', 'low'
    this.globalPerformanceMonitor = new AdvancedPerformanceMonitor();
    this.init();
  }
  init() {
    this.setupVisibilityAPI();
    this.setupIntersectionObservers();
    this.startGlobalPerformanceTracking();
  }
  setupVisibilityAPI() {
    document.addEventListener('visibilitychange', () => {
      this.isVisible = !document.hidden;
      // Pause/resume animations based on visibility
      this.animations.forEach((animation, name) => {
        if (animation.pauseOnHidden) {
          if (this.isVisible) {
            animation.resume?.();
          } else {
            animation.pause?.();
          }
        }
      });
    });
  }
  setupIntersectionObservers() {
    // Enhanced intersection observer for smooth animations
    const observerOptions = {
      threshold: [0, 0.1, 0.25, 0.5, 0.75, 1],
      rootMargin: '50px'
    };
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        const element = entry.target;
        const visibilityRatio = entry.intersectionRatio;
        // Trigger different animation intensities based on visibility
        if (visibilityRatio > 0.1 && !element.classList.contains('animated-in')) {
          this.triggerElementAnimation(element, 'fade-in-up');
          element.classList.add('animated-in');
        }
        // Add parallax effect based on scroll position
        if (visibilityRatio > 0) {
          const translateY = (0.5 - entry.intersectionRatio) * 20;
          element.style.transform = `translateY(${translateY}px)`;
        }
      });
    }, observerOptions);
    // Observe all animatable elements
    document.querySelectorAll('[data-animate], .project-card, .skill-card').forEach(el => {
      observer.observe(el);
    });
  }
  triggerElementAnimation(element, animationType) {
    switch (animationType) {
      case 'fade-in-up':
        element.style.cssText += `
          opacity: 1;
          transform: translateY(0);
          transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        `;
        break;
      case 'scaleIn':
        element.style.cssText += `
          opacity: 1;
          transform: scale(1);
          transition: all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
        `;
        break;
    }
  }
  startGlobalPerformanceTracking() {
    const trackPerformance = () => {
      this.globalPerformanceMonitor.update();
      // Auto-adjust performance mode
      if (this.performanceMode === 'auto') {
        const shouldReduce = this.globalPerformanceMonitor.shouldReduceQuality();
        this.adjustGlobalAnimationQuality(shouldReduce);
      }
      requestAnimationFrame(trackPerformance);
    };
    trackPerformance();
  }
  adjustGlobalAnimationQuality(reduce) {
    const root = document.documentElement;
    if (reduce) {
      root.style.setProperty('--animation-duration', '0.3s');
      root.style.setProperty('--animation-easing', 'ease');
      root.classList.add('reduced-motion-override');
    } else {
      root.style.setProperty('--animation-duration', '0.8s');
      root.style.setProperty('--animation-easing', 'cubic-bezier(0.4, 0, 0.2, 1)');
      root.classList.remove('reduced-motion-override');
    }
  }
  registerAnimation(name, animationObject) {
    this.animations.set(name, animationObject);
  }
  unregisterAnimation(name) {
    const animation = this.animations.get(name);
    if (animation && animation.destroy) {
      animation.destroy();
    }
    this.animations.delete(name);
  }
  getGlobalMetrics() {
    return {
      ...this.globalPerformanceMonitor,
      activeAnimations: this.animations.size,
      visibilityState: this.isVisible ? 'visible' : 'hidden',
      performanceMode: this.performanceMode
    };
  }
}

export class CursorTrailManager {
  constructor() {
    this.trail = [];
    this.maxTrailLength = 8;
    this.isEnabled = !window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (this.isEnabled && !window.matchMedia('(pointer: coarse)').matches) {
      this.init();
    }
  }
  init() {
    this.createTrailElements();
    this.bindEvents();
  }
  createTrailElements() {
    for (let i = 0; i < this.maxTrailLength; i++) {
      const trailElement = document.createElement('div');
      trailElement.className = 'cursor-trail';
      trailElement.style.cssText = `
        position: fixed;
        width: ${12 - i}px;
        height: ${12 - i}px;
        background: var(--tech-emerald);
        border-radius: 50%;
        pointer-events: none;
        z-index: 9999;
        opacity: ${(this.maxTrailLength - i) / this.maxTrailLength * 0.6};
        will-change: transform;
        transform: translate3d(0, 0, 0);
        backface-visibility: hidden;
      `;
      document.body.appendChild(trailElement);
      this.trail.push({
        element: trailElement,
        x: 0,
        y: 0
      });
    }
  }
  bindEvents() {
    let mouseX = 0;
    let mouseY = 0;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let lastUpdateTime = 0;
    let isMouseMoving = false;
    let mouseStopTimeout;
    let animationId;
    // Throttled mouse move handler for better performance
    const handleMouseMove = (e) => {
      const now = performance.now();
      // Throttle mouse events to ~120fps max
      if (now - lastUpdateTime < 8) return;
      lastUpdateTime = now;
      mouseX = e.clientX;
      mouseY = e.clientY;
      // Calculate mouse velocity for adaptive interpolation
      const deltaX = mouseX - lastMouseX;
      const deltaY = mouseY - lastMouseY;
      const velocity = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      // Store velocity for use in animation
      this.mouseVelocity = Math.min(velocity, 50); // Cap at 50px per frame
      lastMouseX = mouseX;
      lastMouseY = mouseY;
      // Start animation if not already running
      if (!isMouseMoving) {
        isMouseMoving = true;
        updateTrail();
      }
      // Reset mouse stop timer
      clearTimeout(mouseStopTimeout);
      mouseStopTimeout = setTimeout(() => {
        isMouseMoving = false;
        if (animationId) {
          cancelAnimationFrame(animationId);
          animationId = null;
        }
      }, 100); // Stop animation 100ms after mouse stops
    };
    document.addEventListener('mousemove', handleMouseMove, { passive: true });
    // Optimized animation loop that only runs when needed
    const updateTrail = () => {
      if (!isMouseMoving) return;
      for (let i = 0; i < this.trail.length; i++) {
        const trail = this.trail[i];
        const targetX = i === 0 ? mouseX : this.trail[i - 1].x;
        const targetY = i === 0 ? mouseY : this.trail[i - 1].y;
        // Adaptive interpolation based on mouse velocity
        // Faster movement = more responsive trail
        const baseInterpolation = 0.2;
        const velocityFactor = Math.min(this.mouseVelocity / 20, 1);
        const interpolation = baseInterpolation + (velocityFactor * 0.3);
        // Smooth interpolation for organic movement
        trail.x += (targetX - trail.x) * interpolation;
        trail.y += (targetY - trail.y) * interpolation;
        // Use transform for better performance than left/top
        trail.element.style.transform = `translate(${trail.x - 6}px, ${trail.y - 6}px)`;
      }
      animationId = requestAnimationFrame(updateTrail);
    };
    // Initialize velocity
    this.mouseVelocity = 0;
  }
}

export class EnhancedTiltManager {
  constructor() {
    this.isEnabled = !window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (this.isEnabled) {
      this.init();
    }
  }
  init() {
    const tiltCards = document.querySelectorAll('[data-tilt]');
    tiltCards.forEach(card => {
      this.setupDynamicTilt(card);
    });
  }
  setupDynamicTilt(element) {
    element.addEventListener('mousemove', (e) => {
      const rect = element.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      const deltaX = (e.clientX - centerX) / (rect.width / 2);
      const deltaY = (e.clientY - centerY) / (rect.height / 2);
      const rotateX = deltaY * -8; // Reduced intensity for subtlety
      const rotateY = deltaX * 8;
      element.style.transform = `
        perspective(1000px)
        rotateX(${rotateX}deg)
        rotateY(${rotateY}deg)
        translateY(-5px)
      `;
      element.style.transition = 'transform 0.1s ease-out';
    });
    element.addEventListener('mouseleave', () => {
      element.style.transform = '';
      element.style.transition = 'transform 0.3s ease-out';
    });
    // Ensure keyboard accessibility
    element.addEventListener('focus', () => {
      element.style.transform = 'perspective(1000px) translateY(-3px)';
    });
    element.addEventListener('blur', () => {
      element.style.transform = '';
    });
  }
}

// Export for backward compatibility
if (typeof window !== 'undefined') {
  window.AnimationController = AnimationController;
  window.StarfieldManager = StarfieldManager;
  window.ScrollSaturationController = ScrollSaturationController;
  window.WebGLParticleSystem = WebGLParticleSystem;
  window.AdvancedCursorTrail = AdvancedCursorTrail;
  window.MagneticFieldController = MagneticFieldController;
  window.EnhancedScrollAnimations = EnhancedScrollAnimations;
  window.EnhancedHoverEffects = EnhancedHoverEffects;
  window.LoadingAnimations = LoadingAnimations;
  window.AnimationPresetManager = AnimationPresetManager;
  window.AdvancedAnimationController = AdvancedAnimationController;
  window.CursorTrailManager = CursorTrailManager;
  window.EnhancedTiltManager = EnhancedTiltManager;
}
